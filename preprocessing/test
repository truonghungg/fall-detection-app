import pandas as pd
import numpy as np
from scipy import stats
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split
import pickle

# 1. Đọc dữ liệu từ file CSV
file_path = 'data/dataset.csv'
df = pd.read_csv(file_path)

# Kiểm tra kích thước ban đầu của dữ liệu
print(f"Original dataset shape: {df.shape}")

# Hiển thị thông tin cơ bản về dữ liệu
print(df.info())
print(df.head())

# 2. Xử lý dữ liệu thiếu và loại bỏ dữ liệu trùng lặp
df.dropna(inplace=True)  # Loại bỏ các hàng có giá trị NaN
df.drop_duplicates(inplace=True)  # Loại bỏ các hàng trùng lặp

# Kiểm tra lại kích thước sau khi xử lý
print(f"Dataset shape after dropping NaN and duplicates: {df.shape}")

# 3. Xử lý nhiễu (Outlier Removal)
# Tính Z-score cho các cột cảm biến
z_scores = np.abs(stats.zscore(df[['AccelX', 'AccelY', 'AccelZ', 'GyroX', 'GyroY', 'GyroZ']]))

# Lọc dữ liệu với ngưỡng Z-score < 3 (loại bỏ outliers)
df = df[(z_scores < 3).all(axis=1)]

# Kiểm tra kích thước sau khi loại bỏ outliers
print(f"Dataset shape after removing outliers: {df.shape}")

# 4. Chuẩn hóa dữ liệu
scaler = StandardScaler()

# Chuẩn hóa các cột cảm biến
df[['AccelX', 'AccelY', 'AccelZ', 'GyroX', 'GyroY', 'GyroZ']] = scaler.fit_transform(
    df[['AccelX', 'AccelY', 'AccelZ', 'GyroX', 'GyroY', 'GyroZ']]
)

# Kiểm tra phân bố sau khi chuẩn hóa
print(df[['AccelX', 'AccelY', 'AccelZ', 'GyroX', 'GyroY', 'GyroZ']].describe())

# 5. Áp dụng Sliding Window
windows = []
labels = []

# Định nghĩa kích thước cửa sổ và bước nhảy
window_size = 100  # Số mẫu trong mỗi cửa sổ
step = 50          # Bước nhảy giữa các cửa sổ

for i in range(0, len(df) - window_size + 1, step):
    window = df.iloc[i:i + window_size]
    
    # Kiểm tra xem tất cả các nhãn trong cửa sổ có giống nhau không
    if len(window['ActivityLabel'].unique()) == 1:
        windows.append(window[['AccelX', 'AccelY', 'AccelZ', 'GyroX', 'GyroY', 'GyroZ']].values)
        labels.append(window['ActivityLabel'].iloc[0])

# Chuyển danh sách thành mảng NumPy
X = np.array(windows)
y = np.array(labels)

# Kiểm tra kích thước của dữ liệu sau khi áp dụng sliding window
print(f"Shape of X: {X.shape}")  # (số cửa sổ, window_size, số cảm biến)
print(f"Shape of y: {y.shape}")  # (số cửa sổ,)

# 6. Mã hóa nhãn hoạt động
label_encoder = LabelEncoder()
y_encoded = label_encoder.fit_transform(y)

# Hiển thị các lớp và nhãn đã mã hóa
print(f"Classes: {label_encoder.classes_}")
print(f"Encoded labels: {y_encoded[:10]}")

# 7. Chia dữ liệu thành tập huấn luyện và kiểm tra
X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.2, random_state=42)

# Hiển thị kích thước của các tập dữ liệu
print(f"Shape of X_train: {X_train.shape}")
print(f"Shape of X_test: {X_test.shape}")
print(f"Shape of y_train: {y_train.shape}")
print(f"Shape of y_test: {y_test.shape}")

# 8. Lưu dữ liệu đã xử lý vào file
with open('preprocessing/processed_data.pkl', 'wb') as f:
    pickle.dump((X_train, X_test, y_train, y_test, label_encoder), f)

# Đọc lại dữ liệu từ file
with open('preprocessing/processed_data.pkl', 'rb') as f:
    X_train, X_test, y_train, y_test, label_encoder = pickle.load(f)